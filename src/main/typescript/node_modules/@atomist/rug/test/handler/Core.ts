import { ScenarioWorld } from "../ScenarioWorld"
import { Result } from "../Result"
import { Message, Plan } from "../../operations/Handlers"
import { GraphNode } from "../../tree/PathExpression"

/**
 * All handler scenario worlds expose the plan,
 * if constructed by code under test.
 */
export interface HandlerScenarioWorld extends ScenarioWorld {

    /**
     * Add this node to the root context so it can 
     * be matched by path expressions other than event handler expressions
     */
    addToRootContext(n: GraphNode): void

    /**
     * Return a single plan. Throws an exception if no plan was recorded
     */
    plan(): Plan

    /**
    * Return all plans recorded
    */
    plans(): Plan[]

    /**
     * A message returned by an handler rather than a Plan
     * Throws an exception if no plan was recorded
     */
    message(): Message

    /**
    * Are all plan(s) internally valid? Do the referenced commands and project operations exist?
    */
    planIsInternallyValid(): boolean 

}

/**
 * Subinterface of ScenarioWorld specific to
 * scenarios testing project operations
 */
export interface CommandHandlerScenarioWorld extends HandlerScenarioWorld {

    /**
     * Return the CommandHandler with the given name, or null if none is found.
     * Pass to invokeHandler
     */
    commandHandler(name: string): any

    /**
     * Execute the given handler, validating parameters
     */
    invokeHandler(commandHandler: any, params?: {})

}

export interface EventHandlerScenarioWorld extends HandlerScenarioWorld {

    /**
     * Register the named handler to respond to input
     * Return the handler, or null if none is found.
     */
    registerHandler(name: string): any

    /**
     * Publish the given event. Should be materialized
     */
    sendEvent(n: GraphNode): void
}


interface Definitions {

    Given(s: string, f: (Project, HandlerScenarioWorld?, ...args) => void): void

    When(s: string, f: (Project, HandlerScenarioWorld?, ...args) => void): void

    Then(s: string, f: (Project, HandlerScenarioWorld?, ...args) => Result | boolean | void): void

}

 // Registered with Nashorn by the test runner
declare var com_atomist_rug_test_gherkin_GherkinRunner$_definitions: Definitions

export function Given(s: string, f: (Project, HandlerScenarioWorld?, ...args) => void) {
    com_atomist_rug_test_gherkin_GherkinRunner$_definitions.Given(s, f)
}

export function When(s: string, f: (Project, HandlerScenarioWorld?, ...args) => void) {
    com_atomist_rug_test_gherkin_GherkinRunner$_definitions.When(s, f)
}


/**
 * A Then step can return a Result object, containing a result and details,
 * a boolean indicating pass or fail, or void.
 * A successful void return is equivalent to true, while throwing an Error
 * means failure. The void return style allows idiomatic use of assertion frameworks
 * such as chai.
 */
export function Then(s: string, f: (Project, HandlerScenarioWorld?, ...args) => Result | boolean | void) {
    com_atomist_rug_test_gherkin_GherkinRunner$_definitions.Then(s, f)
}

// Import well-known step definitions. It's nicer
// to have them in a separate file.
import "./WellKnownSteps.js"
